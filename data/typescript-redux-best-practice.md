---
path: "/blog/typescript-redux-best-practice"
title: "Part 2: Typescript+Redux Best Practice at Vingle"
tags: ["react", "redux", "typescript"]
---

In this part two, I am going to describe our team's current best practices to make Typescript work for you when working with Redux.

* Creating Type-safe Actions and Reducers
* Typing Redux Container
* Typing normalizr and denormalizr

### Creating Type-safe Actions and Reducers

Considering how reducers are just simple functions that accept two arguments, you would expect Typescript to work well with those two. States do. But actions, because `dispatch` accepts any types of arguments, cannot be typed safely without developers' involvement. Before Typescript 2.8, you could achieve type-safety using string enum:

```typescript
enum ActionTypes {
  FETCH_USER = "FETCH_USER",
}

interface IFetchUserAction {
  type: ActionTypes.FETCH_USER;
  payload: { userId: string }
}

interface IOtherAction {
  type: "____________________";
}

type Actions = IFetchUserAction | IOtherAction;

function fetchUser(userId: string): IFetchUserAction {
  return {
    type: ActionTypes.FETCH_USER,
    payload: {
      userId,
    }
  };
}

function reducer(
  state = INITIAL_STATE,
  action: Actions,
): IState {
  switch (action.type) {
    case ActionTypes.FETCH_USER: {
      // in this closure, Typescript knows that action is of interface IFetchUserAction, thanks to enum ActionTypes.
      return {
        ...state,
        userId: action.payload.userId,
      };
    }
    default: {
      return state
    }
  }
```

`IOtherAction` is needed so that Typescript won't complain about default case in switch statement (that is, exhaustiveness checking). This works OK if you ignore the fact that there are essentially two duplicate type definitions in your action interfaces, and action creators. Starting with [Typescript 2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html), you can use `ReturnType` to remove action interfaces.

```typescript
import { ActionCreatorsMapObject } from "redux";
// interface ActionCreatorsMapObject {
//   [key: string]: ActionCreator<any>;
// }

type ActionUnion<T extends ActionCreatorsMapObject> = ReturnType<
  T[keyof T]
>;

enum ActionTypes {
  FETCH_USER = "FETCH_USER",
}

function createAction<T extends { type: ActionTypes }>(d: T): T {
  return d;
}

export const ActionCreators = {
  fetchUser(payload: {userId: string}) =>
    createAction({type: ActionTypes.FETCH_USER, payload}),
}

type Actions = ActionUnion<typeof ActionCreators>;

function reducer(
  state = INITIAL_STATE,
  action: Actions,
): IState {
  switch (action.type) {
    case ActionTypes.FETCH_USER: {
      // in this closure, Typescript knows that action is of ActionCreators.fetchUser's ReturnType.
      return {
        ...state,
        userId: action.payload.userId,
      };
    }
    default: {
      return state
    }
  }
```

### Typing Redux Container

Before you try to type Redux container components properly, you need to understand the type definition of `connect`. Carefully read the code below I exceprted from Redux type definition (comments are mine, tho). The definition uses a lot of type overloading but I will go through some cases to help you understand what exactly goes on.

_Please note that the definition below is from `@types/redux@3.6.31`._

```typescript
export interface DispatchProp<S> {
  dispatch?: Dispatch<S>;
}

export interface InferableComponentEnhancerWithProps<
  TInjectedProps,
  TNeedsProps
> {
  <P extends TInjectedProps>(component: Component<P>): ComponentClass<
    Omit<P, keyof TInjectedProps> & TNeedsProps
  > & { WrappedComponent: Component<P> };
}

export type InferableComponentEnhancer<
  TInjectedProps
> = InferableComponentEnhancerWithProps<TInjectedProps, {}>;

export interface Connect {
  (): InferableComponentEnhancer<DispatchProp<any>>;

  ...

  // this is an all-encompassing definition
  // TStateProps is a type for props generated by mapStateToProps
  // TDispatchProps is a type for props generated by mapDispatchToProps
  // TOwnProps is a type for props from the container component's parent.
  // TMergedProps is a type for props generated by merge.
  // State is a type for Redux store.
  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, TMergedProps = {}, State = {}>(
        mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,
        mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,
        mergeProps: MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps>,
        options: Options<State, TStateProps, TOwnProps, TMergedProps>
    ): InferableComponentEnhancerWithProps<TMergedProps, TOwnProps>;
}
```

#### When you don't pass any argument to connect

This is when you only need `dispatch` inside your container.

```typescript
const Container = (props: { data: any; dispatch: Dispatch<any> }) => {
  // render something and do something useful
  return <div />;
};

export default connect()(Container);
```

As there are no arguments to `connect`, all connect will do is to inject `dispatch<any>` into props.

#### When you pass mapStateToProps to connect

If you want to map only state to props, say for render only components, you

```typescript
type SearchData = { query: string };

type AppState = {
  searchData: SearchData;
};

type Props = { query: string; data: any; dispatch: Dispatch<any> };

function mapStateToProps(state: AppState) {
  return {
    query: state.searchData.query,
  };
}

const Container = (_props: Props) => {
  // render something and do something useful
  return <div />;
};

const A = connect(mapStateToProps)(Container);

<A data />; // this is valid
<A data dispatch={store.dispatch} />; // this isn't valid
```

It almost looks like a magic as Redux type definition does a lot of heavy lifting for us. Let's examine what actually happens inside the code above. The following `connect` definition is the overloaded type definition used in this case.

```typescript
interface Connect {
  <TStateProps = {}, no_dispatch = {}, TOwnProps = {}, State = {}>(
    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,
  ): InferableComponentEnhancerWithProps<
    TStateProps & DispatchProp<any> & TOwnProps,
    TOwnProps
  >;
}
```

```typescript
// The more explicit version will be the following.
type TStateProps = ReturnType<typeof mapStateToProps>;
type TOwnProps = Omit<Props, keyof TStateProps | "dispatch">; // this results in { data: any }. `dispatch` isn't needed if you don't need dispatch in your props.

const B = connect<TStateProps, {}, TOwnProps, AppState>(mapStateToProps)(
  Container,
);

<B data />; // this is valid
<B data dispatch={store.dispatch} />; // this isn't valid
```

#### When you pass both mapStateToProps and mapDispatchToProps to connect

### Extracredit (Typescript tips not related to Redux)

#### How to type HOCs that inject props

#### Use Ambient Types to simplify your dependencies with `typeRoots` option.

#### Know your types in React

Here is the usual go-to list for us.
